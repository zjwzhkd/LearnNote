# C++学习笔记3 - 函数的升级(上)

[TOC]

## 链接属性(Linkage)
1. 无链接(no linkage): 标识符的作用域仅限于当前代码块范围
2. 内部链接(internal linkage): 标识符的作用域限于当前编译单元(源文件)
3. 外部链接(external linkage): 标志符在全部的编译单元(源文件)可以使用

## 常量和宏回顾
* C++中的const常量可以替代宏常数定义, 如:
    * `const int A = 3;`替代`#define A 3`
* 在C++中推荐使用const常量代替宏常量
* const常量一般在头文件中定义
* 全局常量
    * const常量允许在不同的源文件中多次定义
    * 事实上, const常量默认是**内部链接属性**(internal linkage), 仅在文件内有效, 类似于static全局变量
    * 在多个源文件内定义同名的const常量, 等同于在不同的源文件中定义了独立的变量
    * 如果希望定义一个全局的const常量, 共享同一段存储空间, 则需要为const常量声明**外部链接属性**
    * 全局的const常量在**定义**时需要添加`extern`声明

        ```c++
        // 1.cpp
        extern const int a = 1; // 定义一个具有外部链接属性的const常量
        // const int a = 1; // 定义全局常量时, 不能省略extern, 否则该const常量仅在本文件有效

        // 2.cpp
        extern const int a; // 声明外部定义的const常量
        ```

## 内联函数
### 基本概念
* C++中推荐使用内联函数替代宏代码片段
* C++中使用`inline`关联字声明内联函数
* 内联函数声明时`inline`关键字必须和函数定义结合在一起, 否则编译器会直接忽略内联请求
    * `inline`关键字只作用于函数实现, 而不作用于函数声明

    ```c++
    // 忽略内联
    inline int f(int a, int b);
    int f(int a, int b) {};
    ```

* 说明:
    * C++编译器可以将一个函数进行内联编译
    * 被C++编译器内联编译的函数叫做内联函数
    * 内联函数在最终生成的代码中是没有定义的
    * C++编译器直接将内联函数的函数体插入函数调用的地方
    * 内联函数没有普通函数调用时的额外开销(压栈, 跳转, 返回)
    * C++编译器不一定准许函数的内联请求
* 特点:
    * 内联函数是一种特殊的函数, 具有普通函数的特征(参数检查, 返回类型等)
    * 内联函数是对编译器的一种请求, 因此编译器可能拒绝这种请求
    * 内联函数与宏代码片段
        * 内联函数由编译器处理, 直接将编译后的函数体插入调用的地方
        * 宏代码片段由预处理器处理, 进行简单的文本替换, 没有任何编译过程
* 编译器实现:
    * 现代C++编译器能够进行编译优化, 因此一些函数即使没有inline声明, 也可能被编译器内联编译
    * 一些现代C++编译器提供了扩展语法, 能够对函数进行强制内联
        * 如: g++编译器的`__attribute__((always_inline))`属性
    * 将内联函数存入符号表, 用符号表中的函数体替换函数调用
* 限制:
    * 不能存在任何形式的循环语句
    * 不能存在过多的条件判断语句
    * 函数体不能过于庞大
    * 不能对函数进行取址操作
    * 函数内联声明必须在调用语句之前
    * 编译器对于内联的限制并不是绝对的

### 难点分析
* `inline`
    * C++语言中inline函数允许在不同的源文件中多次定义
    * 当某个源文件中使用了inline函数, 则在源文件必须添加inline函数的**定义**
    * 如果inline函数没有声明为static, 则在不同源文件中的定义必须保持一致
    * inline函数一般在头文件中定义
    * 具有外部链接属性的inline函数(没有声明为static)
        * 在不同的源文件中, 必须声明为inline
        * 在不同的源文件中, inline函数具有相同的地址
        * 在不同的源文件中, 静态局部变量共享同一存储空间
* `static inline`
    * static inline函数将具有内部链接属性
    * 在不同源文件中定义的static inline函数, 各自编译为独立的函数
    * 在不同的源文件中, 允许static inline函数具有不同的实现, 函数的实现仅在当前源文件有效
    * 本质上是一个static函数, 并向编译器发起内联请求
    * `static inline`是C语言中遗留的用法, 不推荐在C++中使用
* `extern inline`
    * 在C++中没有相关的语法规定
    * `extern inline`是GUN C的扩展语法

## 函数默认参数
* C++中可以在函数声明时为参数提供一个默认值, 当函数调用时没有指定这个参数的值, 编译器会自动用默认值代替
    * 一般在头文件中声明函数, 并且指定参数的默认值
    * 虽然可以多次声明函数, 但每一个参数只能在函数声明中指定一次默认值, 即不能修改已经存在的默认值

        ```c++
        int add(int a, int b, int c = 0); // 为参数c添加默认值
        int add(int a, int b = 0, int c); // 为参数b补充默认值
        ```

* 函数默认参数的规则
    * 只有参数列表后半部分的参数才可以提供默认参数值
    * 一旦在一个函数调用中开始使用默认参数值, 那么这个参数后的所有参数都必须使用默认参数值

## 函数占位参数
* 占位参数只有参数类型声明, 而没有参数名声明
* 一般情况下, 在函数体内部无法使用占位参数
* 可以将占位参数与默认参数结合起来使用
    * 为以后程序的扩展留下线索
    * 兼容C语言程序中可能出现的不规范写法
