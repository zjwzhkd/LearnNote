# C++学习笔记5 - 新的关键字

[TOC]

## 动态内存分配
* C++中的动态内存分配
    * C++中通过`new`关键字进行动态内存申请
    * C++中的动态内存申请是基于类型进行的
    * `delete`关键字用于内存释放
    * 变量申请

        ```c++
        Type *pointer = new Type;
        // ...
        delete pointer;
        ```

    * 数组申请

        ```c++
        Type *pointer = new Type[N];
        // ...
        delete[] pointer;
        ```

* 变量申请和数组申请
    * 变量申请: `new`和`delete`
    * 数组申请: `new[]`和`delete[]`
    * 变量申请和数组申请的内部实现不同, 不能混用
    * 一个混淆的例子

        ```c++
        typedef int arrT[10];   // arrT是一个数组类型
        arrT *p = new arrT;     // 编译器实际上调用new[], 这里容易混淆
        delete[] p;             // delete[]释放数组
        ```

* new关键字与malloc函数的区别
    * new关键字是C++的一部分, malloc是由C库提供的函数
    * new是以具体类型为单位进行内存分配, malloc只能以字节为单位进行初始化
    * new在申请单个类型变量时可进行初始化, malloc不具备内存初始化的特性

        ```c++
        float *pf = new float(2.0f);    // 初始化申请变量
        delete pf;
        ```

## C++中的命名空间
* 在C语言中只有一个全局作用域
    * C语言中所有的全局标识符共享同一个作用域
    * 标识符之间可能发生冲突
* C++中提出了命名空间的概念
    * 命名空间将全局作用域分成不同的部分
    * 不同命名空间中的标识符可以同名而不会发生冲突
    * 命名空间可以相互嵌套
    * 全局作用域也叫作默认命名空间
* C++命名空间的定义:
    * `namespace name { /* ... */ }`
    * 在同一个命名空间中, 每一个名字表示该空间内的唯一实体, 不同的命名空间内可以有相同的名字
    * 命名空间可以是不连续的, 如果当前定义的命名空间名字不存在, 则定义新的命名空间, 否则向已经存在的命名空间添加新成员
        * 命名空间的不连续性, 使得可以将几个**独立的接口和实现文件**组成一个命名空间
    * 命名空间内的代码, 可以直接使用同一命名空间的名字, 若使用外部命名空间的名字, 则必须加上前缀
        * 例如, 使用std库的类型`uint8_t`, 需要指明`std::uint8_t`
    * 在所有命名空间外的全局作用域称为**默认命名空间**
    * 命名空间服从作用域规则
        * 内层标识符隐藏外层同名标识符
        * 在内层代码中使用的标识符如果不存在, 则依次从外层开始搜寻
* C++命名空间的使用:
    * using指示
        * 使用整个命名空间: `using namespace name;`
        * 在当前作用域, 允许使用整个命名空间的名字
        * 相当于在当前的作用域, 允许使用命名空间内标识符的简略名字, 来代替包含前缀的完整名字
        * 没有改变该命名空间中标识符的作用域
        * 只有在使用到冲突的名字时, 才会产生二义性错误
        * 容易导致多个命名空间的冲突, 一般用于命名空间的实现文件
    * using声明
        * 引入命名空间中的标识符: `using name::variable;`
        * 在当前的作用域引入使用的名字(将标识符引入了当前作用域), 并隐藏上层作用域的同名实体
        * 相当于在当前的作用域, 声明了引入标识符的别名
        * 改变了引入标识符的作用域
        * 如果在当前的作用域存在同名实体, 则产生二义性错误
    * 作用域操作符
        * 使用标识符的完整名字: `name::variable`
        * 默认命名空间的标识符: `::variable`
    * 在程序中可以直接使用默认命名空间中的所有标识符
        * 默认命名空间是除所有命名空间之外的全局作用域
        * 程序中默认使用了默认命名空间
* 未命名的命名空间:
    * `namespace { /* ... */ }`
    * 未命名的命名空间可以在同一文件内不连续, 但不能跨越多个文件
    * 不同文件中的未命名的命名空间是互不相关的
    * 定义在未命名的命名空间中的名字可以直接使用, 不能使用作用域运算符`::`
    * 在C++中使用未命名的命名空间代替`static`进行文件中的静态声明
    * 未命名的命名空间也可以嵌套

        ```c++
        namespace local
        {
            namespace
            {
                int i = 0;
            }
        }

        local::i = 42;
        ```

## 强制类型转换
* C方式的强制类型转换
    * `(Type)(Expression)`或者`Type(Expression)`
* C方式强制类型转换存在的问题
    * 任意类型之间都可以进行转换, 编译器很难判断其正确性
    * 在源码中无法快速定位所有使用强制类型转换的语句
* 在程序设计理论中强制类型转换是不被推荐的, 与goto语句一样, 应该尽量避免
* C++将强制类型转换分为4种不同的类型

    | **static_cast** | **const_cast** |
    | ----- | ----- |
    | **dynamic_cast** | **reinterpret_cast** |

    * 用法: `xxx_cast<Type>(Expression)`

* **static_cast**强制类型转换
    * 用于基本类型间的转换, 但不能用于基本类型指针间的转换
    * 可以将`void*`指针转换为其它类型指针
    * 用于有继承关系类对象之间的转换和类指针之间的转换
    * 在编译期进行转换, 无法在运行时检测类型, 所以类类型之间的转换可能存在风险
* **const_cast**强制类型转换
    * 用于去除变量的const属性
    * 只能改变对象的底层const
        * 顶层const表示任何类型的对象本身是常量
        * 底层const表示指针或引用指向的对象具有const属性

        ```c++
        const int i = 1;    // 顶层const
        const int &k = i;   // 底层const
        const int * const pi = &i;  // 左侧的const是底层const, 右侧的const是顶层const
        ```

* **reinterpret_cast**强制类型转换
    * 用于指针类型之间的强制转换
    * 用于整数和指针类型之间的强制转换
    * `reinterpret_cast`直接从二进制位进行复制, 依赖于底层机器实现, 是一种极其不安全的转换
* **dynamic_cast**强制类型转换
    * 主要用于类层次间的转换, 还可以用于类之间的交叉转换
    * `dynamic_cast`具有类型检查的功能, 比`static_cast`更安全

## 小结
* C++中内置了动态内存分配的专用关键字
* C++中的动态内存分配是基于类型进行的
* C++中命名空间概念用于解决名字冲突问题
* C++细化了C语言中强制类型转换的方式
    * C++不推荐在程序中使用强制类型转换
    * C++建议在强制类型转换时考虑一下究竟希望什么类型的转换
