# C++学习笔记6 - 专题一经典问题解析

[TOC]

## const和引用
1. 使用引用去除const常量的const属性

    ```c++
    const int x = 1;    // 常量值1直接存放在符号表
    int &rx = const_cast<int&>(x);  // const int& --> int&
    rx = 5;
    // x的值 --> 1, 使用符号表的值替换
    // rx的值 --> 5, 分配的内存空间中的值修改为5
    ```
    * 对常量取引用相当于对常量取地址, 将分配一段内存空间保存常量值
    * 直接访问常量时, 将替换为常量定义时记录在符号表中的值

2. 使用volatile修饰const常量

    ```c++
    volatile const int y = 2;   // 只读变量
    int *p = const_cast<int*>(&y);  // const int* --> int*
    *p = 6;
    // y --> 6
    // *p --> 6
    ```
    * 使用volatile修饰的const常量将变为只读变量

3. 使用变量初始化const常量

    ```c++
    int z = 3;
    const int y = z;   // 只读变量
    int *p = const_cast<int*>(&y);  // const int* --> int*
    *p = 7;
    // y --> 7
    // *p --> 7

    ```
    * 使用变量初始化的const常量是只读变量

4. 不同类型的变量初始化const引用

    ```c++
    char c = 'c';
    char &rc = c;
    const int& trc = c; // c的值转换为int类型, 使用转换后的值初始化常引用
    rc = 'a';
    // c --> 'a', rc --> 'a', trc --> 'c'
    ```
    * 不同类型的变量初始化const引用, 相当于将变量的值进行类型转换, 再将转换后的值去初始化const引用

5. 问题解析
    * 符号表
        * 符号表是编译器在编译过程中产生的关于源程序中语法符号的数据结构
        * 符号表是编译器自用的内部数据结构
        * 符号表不会进入最终产生的可执行程序
    * 只有用字面量初始化的const常量才会进入符号表
        * 对const常量引用会导致编译器为其分配空间
        * 虽然const常量可能被分配了空间, 但是这个空间中的值不会被使用
        * 使用其它变量初始化的const常量仍然是只读变量
    * 被volatile修饰的const常量不会进入符号表
        * 退化为只读变量, 每次访问从内存中取值
    * const引用的类型与初始化变量的类型
        * 相同: 为初始化变量设置一个只读的别名
        * 不同: 生成一个新的只读变量, 其初始值为初始化变量经过类型转换后的值
    * **在编译期间不能确定初始值的const常量, 都被作为只读变量处理**

## 引用和指针
* 指针和引用的区别
    * **指针是一个变量**, 其值为一个内存地址, 通过指针可以访问对应内存地址中的值
    * **引用只是一个变量的新名字**, 所有对引用的操作(赋值, 取地址等)都会传递到其引用的变量上
    * 指针可以const修饰成为常量或者只读变量
    * const引用使其引用的变量具有只读属性
    * 指针就是变量, 不需要初始化, 也可以指向不同的地址
    * 引用天生就必须在定义时初始化, 之后无法再引用其它变量
* 理解"引用的本质就是指针常量"
    * 从使用C++语言的角度来看
        * 引用与指针常量没有任何的关系
        * 引用是变量的新名字, 操作引用就是操作对应的变量
    * 从C++编译器的角度来看
        * 为了支持新概念"引用", 必须要有一个有效的解决方案
        * 在编译器内部, 使用指针常量来实现"引用"
        * 因此, 引用在定义时必须初始化
    * 当进行C++编程时, 直接站在使用的角度看待引用, 与指针毫无关系
    * 当对C++程序中的一些涉及引用的bug或者无法理解的行为进行分析时, 可以考虑在C++编译器的角度看待引用

## 函数重载
* C++编译器对字面量的处理方式
    * 整数型字面量的默认类型为int
    * 浮点型字面量的默认类型为double
    * 字符型字面量的默认类型为char
    * 字符串型字面量的默认类型为const char *
* 当使用字面量对变量进行初始化或赋值时
    * 无溢出产生: 编译器对字面量进行默认类型转换
    * 产生溢出: 编译器会做截断操作, 并产生警告
* 函数重载的可行函数
    * 精确匹配实参
    * 通过默认参数能够匹配实参
    * 通过默认类型转换匹配实参
* 最佳匹配的可行函数
    * 该函数每个实参的匹配都不劣于其它的可行函数
    * 至少有一个实参的匹配优于其它的可行函数

## C方式编译
* `extern "C"`告诉C++编译器将其中的代码进行C方式的编译
* C方式编译主要是指按照C语言的规则对函数名进行编译
    * 函数名经过编译后可能与源码中的名字有所不同
    * C++编译器为了支持重载, 函数名经过编译后会加上参数列表信息, 因而编译后的函数名与源码中完全不同
    * C编译器不会在编译后的函数名中加上参数信息
* `extern "C"`中的重载函数经过C方式编译后将得到相同的函数名, 因此`extern "C"`中不允许重载函数, 但`extern "C"`中的函数可以与extern "C"之外的函数进行重载
    * 函数重载发生在编译期间
    * `extern "C"`导致编译的结果不同, 并在链接过程产生影响
